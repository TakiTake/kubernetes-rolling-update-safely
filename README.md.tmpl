Kubernetes rolling update safely
================================

This file is generated by *{{- .TemplateFile -}}*.

## Demo environment

```
minikube version: v0.28.2
```

## Preparations

```shell
# start minikube
$ minikube start

# change docker host to minikube
# then, you can use own docker image from kubernetes without uploading it to some registry
$ eval $(minikube docker-env)

# build demo application
$ docker build -t takitake/demo demo
```

## Demo scenarios

### Default setting

Deploy simple spring-boot application.

```
$ cat demo-manifest/1-0.default.deploy.yml
{{ cat "demo-manifest/1-0.default.deploy.yml" | safeHTML -}}
```

Deploy and watch Pod status. You can see the state transition *ContainerCreating* to *Running*.

```sh
$ kubectl apply -f demo-manifest/1-0.default.deploy.yml && kubectl get pods -w
deployment.extensions "demo" created
NAME                    READY     STATUS              RESTARTS   AGE
demo-67fb9964f4-xmrwj   0/1       ContainerCreating   0          0s
demo-67fb9964f4-xmrwj   1/1       Running   0         1s
```

Let's create the Service to access the deployed demo application.

```sh
$ kubectl apply -f demo-manifest/service.yml
service "demo" created

$ kubectl get service demo
NAME      TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
demo      NodePort   10.111.204.139   <none>        8080:32569/TCP   23s

$ minikube status
minikube: Running
cluster: Running
kubectl: Correctly Configured: pointing to minikube-vm at 192.168.99.100
```

Now you can access the demo application with Kubernetes Service. IP should be the minikube nodeIP and Port should be the NodePort of the demo Service.

This case URL is [http://192.168.99.100:32569/](http://192.168.99.100:32569/). Or you only have to type `minikube service demo` then the URL is opened.

Next, in order to check the rolling update, try changing the appVersion from v1.0 to v1.1

```sh
$ diff "demo-manifest/1-0.default.deploy.yml" "demo-manifest/1-1.default.deploy.yml"
{{ diff "demo-manifest/1-0.default.deploy.yml" "demo-manifest/1-1.default.deploy.yml" | safeHTML -}}
```

```sh
# If you want to check http status also. Following command is usuful to check the status every 1 sec.
$ export DEMO_URL=$(minikube service demo --url)
$ while do curl -s -w " -- `date` -- %{http_code}\n" $DEMO_URL; sleep 1s; done
```

```sh
$ kubectl apply -f demo-manifest/1-1.default.deploy.yml && kubectl get pods -w
deployment.extensions "demo" configured
NAME                    READY     STATUS        RESTARTS   AGE
demo-67fb9964f4-xmrwj   1/1       Terminating   0          1m
demo-7744c47967-c2v9m   0/1       Pending       0          0s
demo-7744c47967-c2v9m   0/1       ContainerCreating   0         0s
demo-67fb9964f4-xmrwj   0/1       Terminating   0         1m
demo-67fb9964f4-xmrwj   0/1       Terminating   0         1m
demo-7744c47967-c2v9m   1/1       Running   0         2s
demo-67fb9964f4-xmrwj   0/1       Terminating   0         1m
demo-67fb9964f4-xmrwj   0/1       Terminating   0         1m
```

After running Pod was terminated, new Pod was created..

Because `maxUnavailable` is 1 by default so only one running Pod was terminated soon.

Dividing the Pod's status into four, the status will change as follows.

![v1.1 rolligng update timeline](img/1-1.png)

There are two solusitions that changing the value to 0 or increasing number of replicas.
Changing the maxUnavailable to 0 this time to simplify the explanation.

### Changing strategy of rolling update

```
$ diff "demo-manifest/1-1.default.deploy.yml" "demo-manifest/1-2.strategy.deploy.yml"
{{ diff "demo-manifest/1-1.default.deploy.yml" "demo-manifest/1-2.strategy.deploy.yml" | safeHTML -}}
```

```sh
$ kubectl apply -f demo-manifest/1-2.strategy.deploy.yml && kubectl get pods -w
deployment.extensions "demo" configured
NAME                    READY     STATUS        RESTARTS   AGE
demo-644fd4dcb-pthk5    0/1       Pending       0          0s
demo-7744c47967-7vbvv   1/1       Terminating   0          53s
demo-644fd4dcb-pthk5   0/1       Pending   0         0s
demo-644fd4dcb-pthk5   0/1       ContainerCreating   0         0s
demo-7744c47967-7vbvv   0/1       Terminating   0         54s
demo-644fd4dcb-pthk5   1/1       Running   0         2s
demo-7744c47967-7vbvv   0/1       Terminating   0         1m
demo-7744c47967-7vbvv   0/1       Terminating   0         1m
```

hmm, still we can lose user's request. Firstly new Pod was created but old Pod was terminated before new Pod became Running status.

![v1.2 rolling update timeline](img/1-2.png)

Because `Ready for Pod` != `Read for Application`. So we need to tell Kubernetes when Application is ready expressly.

### Define ready state of the application

We can configure how to know the application is ready or not yet in manifest file. It is called `ReadinessProbe`.

```
$ diff "demo-manifest/1-2.strategy.deploy.yml" "demo-manifest/1-3.readinessprobe.deploy.yml"
{{ diff "demo-manifest/1-2.strategy.deploy.yml" "demo-manifest/1-3.readinessprobe.deploy.yml" | safeHTML -}}
```

```sh
$ kubectl apply -f demo-manifest/1-3.readinessprobe.deploy.yml && kubectl get pods -w
deployment.extensions "demo" created
NAME                    READY     STATUS              RESTARTS   AGE
```

